using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

public class MapManager : MonoBehaviour
{
    public static MapManager Instance => Utils.MonoSingleton<MapManager>.Instance;
    private bool _hasSpawn;
    private Vector3Int _spawnCell;
    private GameObject _stageRoot;
    private Grid _grid;
    private Tilemap _tmBuildable, _tmUnbuildable, _tmWall, _tmDestructible, _tmDeco, _tmKing, _tmObjects, _tmMonsterSpawn;

    private readonly HashSet<Vector3Int> _occupied = new();
    private readonly Dictionary<Vector3Int, GameObject> _towers = new(); // 셀 → 타워 오브젝트
    public bool IsReady => _grid != null;

    // 네비/배치 변경 알림(타워 설치/제거, 파괴벽 변경 등)
    public Action<Vector3Int> OnCellChanged;

    // ───────────────────────────────────────────────────────────────────────
    // 스테이지 로드/바인드/언로드
    // ───────────────────────────────────────────────────────────────────────
    private void Update()
    {
        if (Input.GetMouseButtonDown(2)) // 중클릭 테스트
        {
            Vector3 mouseWorld = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            mouseWorld.z = 0f; // 2D니까 z 고정
            DebugCheckTowerPlace(mouseWorld);
        }
    }

    public void LoadStage(GameObject stagePrefab)
    {
        UnloadStage();
        _stageRoot = Instantiate(stagePrefab);
        _stageRoot.name = stagePrefab.name;

        CacheMapsFrom(_stageRoot.transform);
        //SetupCollisionLayers();
        WireDestructibleController();
        InitSpawnCell();
    }

    public void BindStageRoot(Transform stageRoot)
    {
        UnloadStage();
        _stageRoot = stageRoot.gameObject;

        CacheMapsFrom(stageRoot);
        //SetupCollisionLayers();
        WireDestructibleController();
        InitSpawnCell();
    }

    public void UnloadStage()
    {
        _occupied.Clear();
        _towers.Clear();
        _grid = null;
        _tmBuildable = _tmUnbuildable = _tmWall = _tmDestructible = _tmDeco = null;

        if (_stageRoot != null)
        {
            Destroy(_stageRoot);
            _stageRoot = null;
        }
    }
    private void InitSpawnCell()
    {
        _hasSpawn = false;
        if (_tmMonsterSpawn == null) return;

        foreach (Vector3Int cell in _tmMonsterSpawn.cellBounds.allPositionsWithin)
        {
            if (_tmMonsterSpawn.HasTile(cell))
            {
                if (_hasSpawn)
                {
                    Debug.LogWarning($"[MapManager] Spawn 타일이 여러 개입니다. 첫 번째({_spawnCell})만 사용, 나머지 {cell} 무시.");
                    continue;
                }
                _spawnCell = cell;
                _hasSpawn = true;
            }
        }
    }

    // ───────────────────────────────────────────────────────────────────────
    // 좌표 유틸
    // ───────────────────────────────────────────────────────────────────────
    public Vector3Int WorldToCell(Vector3 world)
    {
        if (!IsReady) { Debug.LogError("[MapManager] Stage not ready."); return Vector3Int.zero; }
        return _grid.WorldToCell(world);
    }

    public Vector3 CellCenterWorld(Vector3Int cell)
    {
        if (!IsReady) { Debug.LogError("[MapManager] Stage not ready."); return Vector3.zero; }
        return _grid.GetCellCenterWorld(cell);
    }

    // ───────────────────────────────────────────────────────────────────────
    // 경량 구조체 & 편의 API (배치/길찾기 전용)
    // ───────────────────────────────────────────────────────────────────────

    public readonly struct PlaceInfo
    {
        public readonly Vector3Int Cell;
        public readonly bool Placeable; // 지금 즉시 설치 가능한가?
        public readonly bool Occupied;  // 점유돼 있는가?

        public PlaceInfo(Vector3Int cell, bool placeable, bool occupied)
        { this.Cell = cell; this.Placeable = placeable; this.Occupied = occupied; }
    }
    public PlaceInfo GetPlaceInfo(Vector3Int cell)
    {
        bool occupied = _towers.ContainsKey(cell) || _occupied.Contains(cell);
        bool placeable =
            (_tmBuildable && _tmBuildable.HasTile(cell)) &&
            !occupied &&
            !((_tmWall && _tmWall.HasTile(cell)) || (_tmDestructible && _tmDestructible.HasTile(cell)));

        return new PlaceInfo(cell, placeable, occupied);
    }
    public PlaceInfo GetPlaceInfoWorld(Vector3 worldPos) => GetPlaceInfo(WorldToCell(worldPos));
    // 스테이지 진입 시 플레이어 베이스 배치 가능 타일 Get용
    // 현재 맵의 모든 KingTile 셀 나열
    public List<Vector3Int> GetAllKingCells()
    {
        var list = new List<Vector3Int>();
        if (_tmKing == null) return list;
        foreach (var c in _tmKing.cellBounds.allPositionsWithin)
            if (_tmKing.HasTile(c)) list.Add(c);
        return list;
    }

    // 선택된 KingTile을 Buildable로 전환
    public bool ConvertKingToBuildable(Vector3Int cell)
    {
        if (_tmKing == null || !_tmKing.HasTile(cell)) return false;
        _tmKing.SetTile(cell, null);
        OnCellChanged?.Invoke(cell);  // 길찾기/배치 갱신 알림
        return true;
    }
    public bool SelectPlayerBase(Vector3Int selectedCell, GameObject basePrefab = null, bool occupyBaseCell = true)
    {
        if (_tmKing == null) return false;
        if (!_tmKing.HasTile(selectedCell)) return false; // King 후보가 아닌 칸이면 실패

        // 1) King 후보들 수집
        var kings = GetAllKingCells();
        if (kings.Count == 0) return false;

        // 2) 모두 처리
        foreach (var c in kings)
        {
            // King 타일 제거
            _tmKing.SetTile(c, null);

            if (c == selectedCell)
            {
                // 선택 칸: 베이스 확정
                if (basePrefab != null)
                {
                    var pos = CellCenterWorld(c);
                    var go = Instantiate(basePrefab, pos, Quaternion.identity, _stageRoot?.transform);
                    go.name = basePrefab.name;
                }

                if (occupyBaseCell)
                    MarkOccupied(c); // 베이스 셀은 타워 설치 불가로 막음
            }
            OnCellChanged?.Invoke(c);
        }
        return true;
    }

    public readonly struct NavInfo
    {
        public readonly Vector3Int Cell;
        public readonly bool Blocked;        // 이동 불가 전체 판단
        public readonly bool BlockedByTower; // 타워/점유로 인해 막힘
        public readonly bool BlockedByWall;  // 벽/파괴벽으로 막힘

        public NavInfo(Vector3Int cell, bool blocked, bool blockedByTower, bool blockedByWall)
        { this.Cell = cell; this.Blocked = blocked; this.BlockedByTower = blockedByTower; this.BlockedByWall = blockedByWall; }
    }
    public NavInfo GetNavInfo(Vector3Int cell)
    {
        bool byWall = (_tmWall && _tmWall.HasTile(cell)) || (_tmDestructible && _tmDestructible.HasTile(cell));
        bool byTower = _towers.ContainsKey(cell) || _occupied.Contains(cell);
        bool blocked = byWall || byTower;
        return new NavInfo(cell, blocked, byTower, byWall);
    }
    public NavInfo GetNavInfoWorld(Vector3 worldPos) => GetNavInfo(WorldToCell(worldPos));
    //몬스터 스폰 타일 Get용
    //public List<Vector3Int> GetSpawnCells()
    //{
    //    var list = new List<Vector3Int>();
    //    if (_tmMonsterSpawn == null) return list;
    //    foreach (var c in _tmMonsterSpawn.cellBounds.allPositionsWithin)
    //        if (_tmMonsterSpawn.HasTile(c)) list.Add(c);
    //    return list;
    //}
    //실수 방지
    public bool TryGetSpawnCell(out Vector3Int cell)
    {
        cell = _spawnCell;
        return _hasSpawn;
    }
    //몬스터 스폰 타일 Get용
    public Vector3 GetSpawnWorld()
    {
        return _hasSpawn ? CellCenterWorld(_spawnCell) : Vector3.zero;
    }
    //
    //public bool IsTowerPlaceableCell(Vector3Int cell) => GetPlaceInfo(cell).placeable;
    //public bool IsTowerPlaceableWorld(Vector3 worldPos) => GetPlaceInfoWorld(worldPos).placeable;
    //
    //public bool IsBlockedCell(Vector3Int cell) => GetNavInfo(cell).blocked;
    //public bool IsBlockedWorld(Vector3 worldPos) => GetNavInfoWorld(worldPos).blocked;
    //
    //public bool IsBlockedByTower(Vector3Int cell) => GetNavInfo(cell).blockedByTower;

    //몬스터가 타워 공격 하는 용
    public bool TryGetTowerAt(Vector3Int cell, out GameObject tower) => _towers.TryGetValue(cell, out tower);
    //
    //public bool HasTower(Vector3Int cell) => _towers.ContainsKey(cell);
    //public bool IsWall(Vector3Int cell) => _tmWall && _tmWall.HasTile(cell);
    //public bool IsDestructible(Vector3Int cell) => _tmDestructible && _tmDestructible.HasTile(cell);
    //public bool IsBuildable(Vector3Int cell) => _tmBuildable && _tmBuildable.HasTile(cell);

    // ───────────────────────────────────────────────────────────────────────
    // 배치/점유 갱신
    // ───────────────────────────────────────────────────────────────────────
    public void MarkOccupied(Vector3Int tile)
    {
        _occupied.Add(tile);
        OnCellChanged?.Invoke(tile);
    }

    public void UnmarkOccupied(Vector3Int tile)
    {
        _occupied.Remove(tile);
        OnCellChanged?.Invoke(tile);
    }

    // 설치 직후 호출: RegisterTower(cell, towerInstance);
    public void RegisterTower(Vector3Int cell, GameObject tower)
    {
        _towers[cell] = tower;
        _occupied.Add(cell);              // 점유 표기
        OnCellChanged?.Invoke(cell);
    }

    // 파괴/판매 시 호출: UnregisterTower(cell);
    public void UnregisterTower(Vector3Int cell)
    {
        _towers.Remove(cell);
        _occupied.Remove(cell);
        OnCellChanged?.Invoke(cell);
    }

    // ───────────────────────────────────────────────────────────────────────
    // 파괴벽 처리
    // ───────────────────────────────────────────────────────────────────────
    public void ConvertDestructibleToBuildable(Vector3Int cell)
    {
        if (!IsReady || _tmDestructible == null) return;
        if (_tmDestructible.HasTile(cell))
        {
            _tmDestructible.SetTile(cell, null); // 밑의 Buildable이 그대로 드러남
            //_tmDestructible.GetComponent<TilemapCollider2D>()?.ProcessTilemapChanges();
            OnCellChanged?.Invoke(cell);
        }
    }

    // ───────────────────────────────────────────────────────────────────────
    // 내부 구현
    // ───────────────────────────────────────────────────────────────────────
    private void CacheMapsFrom(Transform stageRoot)
    {
        _grid = stageRoot.GetComponent<Grid>();
        if (_grid == null)
        {
            Debug.LogError("[MapManager] Grid not found on stage root.");
            return;
        }

        _tmBuildable = FindByName(stageRoot, "Build")?.GetComponent<Tilemap>();
        _tmUnbuildable = FindByName(stageRoot, "UnBuild")?.GetComponent<Tilemap>();
        _tmWall = FindByName(stageRoot, "UnDeWall")?.GetComponent<Tilemap>();
        _tmDestructible = FindByName(stageRoot, "DeWall")?.GetComponent<Tilemap>();
        _tmDeco = FindByName(stageRoot, "Decotile")?.GetComponent<Tilemap>();
        _tmKing = FindByName(stageRoot, "KingTile")?.GetComponent<Tilemap>();
        _tmObjects = FindByName(stageRoot, "ObjectsTile")?.GetComponent<Tilemap>();
        _tmMonsterSpawn = FindByName(stageRoot, "MonsterSpawnTile")?.GetComponent<Tilemap>();
    }

    private Transform FindByName(Transform root, string name)
    {
        if (root.name == name) return root;
        for (int i = 0; i < root.childCount; i++)
        {
            Transform child = root.GetChild(i);
            Transform found = FindByName(child, name);
            if (found) return found;
        }
        return null;
    }

    //private void SetupCollisionLayers()
    //{
    //    // Buildable: 충돌 X
    //    DisableCollider(_tmBuildable);
    //
    //    // Wall/Destructible: 충돌 O
    //    SetupCollider(_tmWall, CompositeCollider2D.GeometryType.Outlines);
    //    SetupCollider(_tmDestructible, CompositeCollider2D.GeometryType.Outlines);
    //
    //    // Deco, UnBuildable: 충돌 X (필요 시 UnBuildable에 충돌 켜도 됨)
    //    DisableCollider(_tmDeco);
    //    DisableCollider(_tmUnbuildable);
    //}
    //
    //private void DisableCollider(Tilemap tilemap)
    //{
    //    if (!tilemap) return;
    //    TilemapCollider2D collider = tilemap.GetComponent<TilemapCollider2D>();
    //    if (collider) collider.enabled = false;
    //    Rigidbody2D rigid = tilemap.GetComponent<Rigidbody2D>();
    //    if (rigid) rigid.simulated = false;
    //    CompositeCollider2D composite = tilemap.GetComponent<CompositeCollider2D>();
    //    if (composite) composite.enabled = false;
    //}
    //
    //private void SetupCollider(Tilemap tilemap, CompositeCollider2D.GeometryType geoType)
    //{
    //    if (!tilemap) return;
    //
    //    TilemapCollider2D tileCol = tilemap.GetComponent<TilemapCollider2D>() ?? tilemap.gameObject.AddComponent<TilemapCollider2D>();
    //    tileCol.isTrigger = false;
    //    tileCol.usedByComposite = true;
    //
    //    CompositeCollider2D composite = tilemap.GetComponent<CompositeCollider2D>() ?? tilemap.gameObject.AddComponent<CompositeCollider2D>();
    //    composite.geometryType = geoType;
    //    composite.generationType = CompositeCollider2D.GenerationType.Synchronous;
    //
    //    Rigidbody2D rigid = tilemap.GetComponent<Rigidbody2D>() ?? tilemap.gameObject.AddComponent<Rigidbody2D>();
    //    rigid.bodyType = RigidbodyType2D.Static;
    //}
    //
    private void WireDestructibleController()
    {
        if (_tmDestructible == null) return;
        DestructibleWall ctrl = _tmDestructible.GetComponent<DestructibleWall>();
        if (!ctrl) ctrl = _tmDestructible.gameObject.AddComponent<DestructibleWall>();
        ctrl.Init(this, _tmDestructible);
    }

    // ───────────────────────────────────────────────────────────────────────
    // 오브젝트 타일 상호작용 관련
    // ───────────────────────────────────────────────────────────────────────
    // 해당 셀이 ObjectsTile인가?
    //public bool IsObjectTile(Vector3Int cell) => _tmObjects && _tmObjects.HasTile(cell);

    // 효과 트리거 이벤트(타일 이름을 함께 넘김)
    //public event Action<Vector3Int, string> OnObjectTileTriggered;

    // 효과 사용: 타일 제거 + 이벤트 발행
    //public bool UseObjectTile(Vector3Int cell)
    //{
    //    if (_tmObjects == null || !_tmObjects.HasTile(cell)) return false;
    //
    //    // 어떤 오브젝트였는지 식별(타일 이름 활용)
    //    string tileName = _tmObjects.GetTile(cell)?.name ?? "Object";
    //    _tmObjects.SetTile(cell, null);
    //
    //    OnObjectTileTriggered?.Invoke(cell, tileName);
    //    OnCellChanged?.Invoke(cell); // 필요 시 네비 갱신(비차단이라 영향은 없음)
    //    return true;
    //}

    // ───────────────────────────────────────────────────────────────────────
    // 맵 바운드/디버그
    // ───────────────────────────────────────────────────────────────────────
    public BoundsInt GetNavBounds()
    {
        if (!IsReady) return new BoundsInt(Vector3Int.zero, Vector3Int.zero);

        bool any = false;
        BoundsInt mapbounds = new BoundsInt();

        void Accumulate(Tilemap tilemap)
        {
            if (!tilemap) return;
            BoundsInt bounds = tilemap.cellBounds;
            if (!any) { mapbounds = bounds; any = true; }
            else
            {
                var min = Vector3Int.Min(mapbounds.min, bounds.min);
                var max = Vector3Int.Max(mapbounds.max, bounds.max);
                mapbounds = new BoundsInt(min, max - min);
            }
        }

        Accumulate(_tmBuildable);
        Accumulate(_tmUnbuildable);
        Accumulate(_tmWall);
        Accumulate(_tmDestructible);
        Accumulate(_tmDeco);
        Accumulate(_tmKing);
        Accumulate(_tmObjects);
        Accumulate(_tmMonsterSpawn);


        return mapbounds;
    }
    // 맵 전체 셀 범위/크기/셀 월드 크기
    public void GetNavFrame(out Vector3Int originCell, out Vector3Int sizeCells, out Vector3 cellSize)
    {
        BoundsInt b = GetNavBounds();
        originCell = b.min;      
        sizeCells = b.size;      
        cellSize = _grid != null ? _grid.cellSize : Vector3.one;
    }


    // 실험/디버그용
    public void GetCellFlags(Vector3Int c, out bool buildable, out bool unbuildable, out bool wall, out bool destructible, out bool deco, out bool occupied)
    {
        buildable = _tmBuildable && _tmBuildable.HasTile(c);
        unbuildable = _tmUnbuildable && _tmUnbuildable.HasTile(c);
        wall = _tmWall && _tmWall.HasTile(c);
        destructible = _tmDestructible && _tmDestructible.HasTile(c);
        deco = _tmDeco && _tmDeco.HasTile(c);
        occupied = _towers.ContainsKey(c) || _occupied.Contains(c);
    }

    public void DebugCheckTowerPlace(Vector3 worldPos)
    {
        if (!IsReady) return;
        var info = GetPlaceInfoWorld(worldPos);
        Debug.Log($"셀 {WorldToCell(worldPos)} : {(info.Placeable ? "타워 설치 가능" : "설치 불가")} / 점유={info.Occupied}");
    }
}